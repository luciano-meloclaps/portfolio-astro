---
// src/components/modules/ContactForm.astro
// =========================================
// Formulario de contacto conectado a API Real (Resend)
// Caracter√≠sticas:
// - Validaci√≥n TypeScript tipada
// - Conexi√≥n as√≠ncrona a /api/send-email
// - Feedback visual y manejo de errores reales

import FormField from '@/components/ui/FormField.astro';
import { IconSend } from '@tabler/icons-react';
---

<!-- Formulario de Contacto -->
<form id="contact-form" class="flex flex-1 flex-col space-y-6" novalidate>
  <!-- Campo: Nombre -->
  <FormField id="name" label="Nombre *" type="text" required />

  <!-- Campo: Email -->
  <FormField id="email" label="Email *" type="email" required />

  <!-- Campo: Asunto -->
  <FormField id="subject" label="Asunto *" type="text" required />

  <!-- Campo: Mensaje -->
  <FormField id="message" label="Mensaje *" as="textarea" required />

  <!-- Submit Button -->
  <div class="mt-auto pt-6">
    <button
      type="submit"
      class="relative inline-flex w-full items-center justify-center gap-x-2 overflow-hidden rounded-small border border-text-primary bg-text-primary px-6 py-3 font-sans text-sm uppercase tracking-wider text-background transition-all duration-300 ease-out hover:bg-transparent hover:text-text-primary focus:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:ring-offset-background active:scale-95 disabled:cursor-not-allowed disabled:opacity-50"
    >
      <span class="relative z-10 flex items-center justify-center gap-x-2">
        <span id="submit-text">Enviar Mensaje</span>
        <IconSend className="icon-base h-4 w-4" id="submit-icon" />
      </span>
    </button>
  </div>
</form>

<script>
  import gsap from 'gsap';
  import { validateContactForm, validateField } from '@/lib/formValidation';

  interface FieldConfig {
    element: HTMLInputElement | HTMLTextAreaElement;
    type: 'name' | 'email' | 'subject' | 'message';
  }

  function initContactFormValidation(): void {
    const form = document.getElementById('contact-form') as HTMLFormElement;
    if (!form) return;

    const nameField = document.getElementById('name') as HTMLInputElement;
    const emailField = document.getElementById('email') as HTMLInputElement;
    const subjectField = document.getElementById('subject') as HTMLInputElement;
    const messageField = document.getElementById(
      'message'
    ) as HTMLTextAreaElement;
    const submitBtn = form.querySelector(
      'button[type="submit"]'
    ) as HTMLButtonElement;

    if (
      !nameField ||
      !emailField ||
      !subjectField ||
      !messageField ||
      !submitBtn
    ) {
      console.error('[ContactForm] Missing required form elements');
      return;
    }

    const fieldConfig: Record<string, FieldConfig> = {
      name: { element: nameField, type: 'name' },
      email: { element: emailField, type: 'email' },
      subject: { element: subjectField, type: 'subject' },
      message: { element: messageField, type: 'message' },
    };

    const debounceTimers = new Map<string, ReturnType<typeof setTimeout>>();

    // --- FUNCIONES DE UI (Show/Hide Errors) ---
    function showFieldMessage(
      fieldId: string,
      message: string | null,
      isValid: boolean = false
    ): void {
      const fieldElement = document.getElementById(fieldId);
      if (!fieldElement) return;

      const fieldContainer = fieldElement.closest('.form-field');
      const errorMessageEl = fieldContainer?.querySelector(
        '.error-message'
      ) as HTMLElement | null;
      const helperMessageEl = fieldContainer?.querySelector(
        '.helper-message'
      ) as HTMLElement | null;

      if (!errorMessageEl || !helperMessageEl) return;

      if (message) {
        fieldElement.setAttribute('aria-invalid', isValid ? 'false' : 'true');
        if (isValid) {
          helperMessageEl.textContent = message;
          helperMessageEl.classList.remove('hidden');
          errorMessageEl.classList.add('hidden');
          fieldElement.setAttribute('data-valid', 'true');
          gsap.fromTo(
            helperMessageEl,
            { opacity: 0, y: -5 },
            { opacity: 1, y: 0, duration: 0.2, ease: 'power2.out' }
          );
        } else {
          errorMessageEl.textContent = message;
          errorMessageEl.classList.remove('hidden');
          helperMessageEl.classList.add('hidden');
          fieldElement.removeAttribute('data-valid');
          gsap.fromTo(
            errorMessageEl,
            { opacity: 0, y: -5 },
            { opacity: 1, y: 0, duration: 0.2, ease: 'power2.out' }
          );
        }
      } else {
        fieldElement.setAttribute('aria-invalid', 'false');
        fieldElement.removeAttribute('data-valid');
        gsap.to([errorMessageEl, helperMessageEl], {
          opacity: 0,
          y: -5,
          duration: 0.15,
          ease: 'power2.in',
          onComplete: () => {
            errorMessageEl.classList.add('hidden');
            helperMessageEl.classList.add('hidden');
            errorMessageEl.textContent = '';
            helperMessageEl.textContent = '';
          },
        });
      }
    }

    function validateFieldOnChange(fieldId: keyof typeof fieldConfig): void {
      const config = fieldConfig[fieldId];
      const error = validateField(config.element.value, config.type);
      showFieldMessage(fieldId, error);
    }

    // --- EVENT LISTENERS ---
    Object.entries(fieldConfig).forEach(([fieldId, config]) => {
      const { element } = config;
      element.addEventListener('blur', () => {
        element.setAttribute('data-touched', 'true');
        validateFieldOnChange(fieldId as keyof typeof fieldConfig);
      });
      element.addEventListener('change', () => {
        validateFieldOnChange(fieldId as keyof typeof fieldConfig);
      });
      element.addEventListener('input', () => {
        const existingTimer = debounceTimers.get(fieldId);
        if (existingTimer) clearTimeout(existingTimer);
        const newTimer = setTimeout(() => {
          if (element.hasAttribute('data-touched')) {
            validateFieldOnChange(fieldId as keyof typeof fieldConfig);
          }
          debounceTimers.delete(fieldId);
        }, 300);
        debounceTimers.set(fieldId, newTimer);
      });
    });

    /**
     * üöÄ FUNCI√ìN CR√çTICA ACTUALIZADA
     * Env√≠a los datos reales al endpoint /api/send-email
     */
    async function sendFormDataToAPI(formData: {
      name: string;
      email: string;
      subject: string;
      message: string;
    }): Promise<{ success: boolean }> {
      // Llamada real a tu servidor Serverless
      const response = await fetch('/api/send-email', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(formData),
      });

      const result = await response.json();

      // Si el servidor (send-email.ts) devuelve error, lanzamos excepci√≥n
      if (!response.ok) {
        throw new Error(result.error || 'Error al conectar con el servidor');
      }

      return { success: true };
    }

    // --- MANEJO DEL SUBMIT ---
    form.addEventListener('submit', async (e) => {
      e.preventDefault();

      const formData = {
        name: nameField.value,
        email: emailField.value,
        subject: subjectField.value,
        message: messageField.value,
      };

      const validation = validateContactForm(formData);

      if (!validation.isValid) {
        Object.entries(validation.errors).forEach(([fieldId, error]) => {
          showFieldMessage(fieldId, error);
          const field = document.getElementById(fieldId);
          if (field) field.setAttribute('data-touched', 'true');
        });
        return;
      }

      submitBtn.disabled = true;
      const submitText = submitBtn.querySelector(
        '#submit-text'
      ) as HTMLElement | null;
      const originalText = submitText?.textContent || 'Enviar Mensaje';
      if (submitText) submitText.textContent = 'Enviando...';

      try {
        // üî• AQU√ç LLAMAMOS A LA NUEVA FUNCI√ìN REAL
        const response = await sendFormDataToAPI(formData);

        if (response.success) {
          (window as any).formModal?.open('success');
          form.reset();
          Object.keys(fieldConfig).forEach((fieldId) => {
            showFieldMessage(fieldId, null);
            const field = document.getElementById(fieldId);
            if (field) field.removeAttribute('data-touched');
          });
        }
      } catch (error) {
        console.error('[ContactForm] Error real de env√≠o:', error);
        // Si falla, abrimos el modal de error
        (window as any).formModal?.open('error');
      } finally {
        submitBtn.disabled = false;
        if (submitText) submitText.textContent = originalText;
      }
    });

    const cleanup = (): void => {
      debounceTimers.forEach((timer) => clearTimeout(timer));
      debounceTimers.clear();
    };

    document.addEventListener('astro:before-swap', cleanup);
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initContactFormValidation);
  } else {
    initContactFormValidation();
  }

  document.addEventListener('astro:page-load', initContactFormValidation);
</script>
