---
// src/components/ui/SectionTitle.astro
interface Props {
  title: string;
  subtitle?: string;
  class?: string;
}

const { title, subtitle, class: className } = Astro.props;
---

<div
  class:list={[
    'section-title-wrapper group mb-16 flex w-full select-none flex-col items-center text-center',
    className,
  ]}
>
  <h2 class="sr-only">{title}</h2>

  <!-- 
    SOLUCIÓN DEFINITIVA:
    - UN ÚNICO ELEMENTO que se anima
    - El ::before es SOLO para visualización del stroke (no se anima)
    - Evita completamente el problema de dos elementos desincronizados
  -->
  <div class="relative inline-flex overflow-hidden" aria-hidden="true">
    <span
      class="text-h1 font-bold uppercase tracking-tighter text-text-primary will-change-opacity"
      data-role="text"
    >
      {title}
    </span>
  </div>

  {
    subtitle && (
      <p
        class="mt-4 max-w-lg translate-y-4 text-sm font-light leading-relaxed text-text-secondary opacity-0 md:text-base"
        data-role="subtitle"
      >
        {subtitle}
      </p>
    )
  }
</div>

<style>
  /* SectionTitle: Sin stroke, solo fill animado - animación limpia sin glitch */
</style>

<script>
  import gsap from 'gsap';
  import { ScrollTrigger } from 'gsap/ScrollTrigger';
  import { scrambleText } from '@/lib/animations';

  gsap.registerPlugin(ScrollTrigger);

  function initSectionTitles() {
    const wrappers = document.querySelectorAll('.section-title-wrapper');

    wrappers.forEach((wrapper) => {
      if (wrapper.hasAttribute('data-init')) return;
      wrapper.setAttribute('data-init', 'true');

      const textEl = wrapper.querySelector('[data-role="text"]') as HTMLElement;
      const subtitleEl = wrapper.querySelector('[data-role="subtitle"]');

      const realTitle = textEl.textContent?.trim() || '';

      let currentTl: gsap.core.Timeline | null = null;

      const playAnimation = () => {
        // Matar timeline anterior
        if (currentTl) currentTl.kill();

        // Resetear estado
        textEl.innerText = realTitle;
        Object.keys(textEl.dataset).forEach((key) => {
          if (key.startsWith('char')) delete textEl.dataset[key];
        });

        currentTl = gsap.timeline();

        // Animar el ÚNICO elemento (fill solamente, sin stroke)
        currentTl.add(scrambleText(textEl, realTitle, 1.0), 0);

        // Animar subtitle
        if (subtitleEl) {
          currentTl.to(subtitleEl, { opacity: 1, y: 0, duration: 0.5 }, 0.5);
        }
      };

      // ScrollTrigger para entrada - se repite cada vez que entra en viewport
      ScrollTrigger.create({
        trigger: wrapper,
        start: 'top 85%',
        onEnter: playAnimation,
      });

      // Hover para re-trigger
      wrapper.addEventListener('mouseenter', () => {
        if (currentTl && currentTl.isActive()) return;
        playAnimation();
      });
    });
  }

  document.addEventListener('astro:page-load', initSectionTitles);
  document.addEventListener('DOMContentLoaded', initSectionTitles);
</script>
